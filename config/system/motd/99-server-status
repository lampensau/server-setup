#!/bin/sh
# Enhanced MOTD - Modular architecture with optimal performance
# Based on your excellent foundation with additional optimizations

# Configuration
CACHE_DIR="${MOTD_CACHE_DIR:-/tmp/.motd-cache}"
CACHE_TTL_UPDATES=60    # 1 hour
CACHE_TTL_AUTOREMOVE=30 # 30 minutes
SERVICES_TO_CHECK="${MOTD_SERVICES:-ssh nginx caddy apache2 mysql mariadb postgresql redis docker postfix ufw fail2ban}"

# Colors
R='\033[0;31m'; G='\033[0;32m'; Y='\033[1;33m'; B='\033[0;34m'; C='\033[0;36m'; W='\033[1;37m'; NC='\033[0m'

# Utility functions
command_exists() { command -v "$1" >/dev/null 2>&1; }

check_cache_file() {
    local file="$1" ttl="$2"
    [ ! -f "$file" ] || [ -n "$(find "$file" -mmin +$ttl 2>/dev/null)" ]
}

safe_cache_write() {
    local content="$1" file="$2"
    echo "$content" > "${file}.tmp" 2>/dev/null && mv "${file}.tmp" "$file" 2>/dev/null
}

svc_check() {
    if systemctl is-active --quiet "$1" 2>/dev/null; then 
        echo "${G}UP${NC}"
    else 
        echo "${R}DOWN${NC}"
    fi
}

# Initialize cache directory
[ ! -d "$CACHE_DIR" ] && mkdir -p "$CACHE_DIR" 2>/dev/null

# System info - Direct kernel access for maximum performance
H=$(hostname -f 2>/dev/null || hostname)

# Uptime and load from /proc (much faster than external commands)
if [ -r /proc/uptime ] && [ -r /proc/loadavg ]; then
    UPTIME_SECONDS=$(cut -d' ' -f1 /proc/uptime | cut -d'.' -f1)
    DAYS=$((UPTIME_SECONDS / 86400))
    HOURS=$(((UPTIME_SECONDS % 86400) / 3600))
    MINS=$(((UPTIME_SECONDS % 3600) / 60))
    UP="${DAYS}d ${HOURS}h ${MINS}m"
    LOAD=$(cut -d' ' -f1-3 /proc/loadavg)
else
    # Fallback for systems without /proc
    UPTIME_OUTPUT=$(timeout 2 uptime 2>/dev/null)
    UP=$(echo "$UPTIME_OUTPUT" | sed 's/.*up \([^,]*\).*/\1/' | sed 's/ days\?/d/g' | sed 's/ hours\?/h/g' | sed 's/ minutes\?/m/g')
    LOAD=$(echo "$UPTIME_OUTPUT" | awk -F'load average:' '{print $2}' | xargs)
fi

# Memory from /proc/meminfo (faster than free command)
if [ -r /proc/meminfo ]; then
    MEMINFO=$(cat /proc/meminfo)
    MEM_TOTAL=$(echo "$MEMINFO" | awk '/MemTotal/ {print $2}')
    MEM_AVAIL=$(echo "$MEMINFO" | awk '/MemAvailable/ {print $2}')
    MEM=$(awk "BEGIN {printf \"%.0f%%\", (($MEM_TOTAL-$MEM_AVAIL)/$MEM_TOTAL)*100}")
else
    MEM=$(free | grep '^Mem:' | awk '{printf("%.0f%%", $3/$2*100)}')
fi

# Disk usage
DISK=$(df -h / | tail -1 | awk '{print $5}')

# Network - Optimized IP detection
# Try route-based detection first (faster), fallback to interface parsing
IPS=$(ip -4 route get 1.1.1.1 2>/dev/null | grep -Po 'src \K[0-9.]+' 2>/dev/null)
if [ -z "$IPS" ]; then
    IPS=$(ip -4 addr show | awk '
        /^[0-9]+:/ { iface=$2; gsub(/:/, "", iface) }
        /inet / && iface !~ /^(lo|docker|br-|veth|coolify)/ && /scope global/ { 
            split($2, ip, "/"); print ip[1] 
        }' | paste -sd',' - | sed 's/,/, /g')
fi
[ -z "$IPS" ] && IPS="none"

# Service status - Optimized with single systemctl call
SVCS=""
INACTIVE=0
ACTIVE_SERVICES=$(timeout 2 systemctl list-units --type=service --state=active --no-legend 2>/dev/null | awk '{print $1}' | sed 's/\.service$//')

# Remove duplicates and check services
SERVICES_CLEAN=$(echo "$SERVICES_TO_CHECK" | tr ' ' '\n' | sort -u | tr '\n' ' ')
for svc in $SERVICES_CLEAN; do
    if echo "$ACTIVE_SERVICES" | grep -q "^$svc$"; then
        SVCS="$SVCS$svc: ${G}UP${NC}  "
    elif systemctl list-unit-files 2>/dev/null | grep -q "^$svc\.service"; then
        SVCS="$SVCS$svc: ${R}DOWN${NC}  "
        INACTIVE=$((INACTIVE + 1))
    fi
done
[ "$INACTIVE" -gt 0 ] && SVCS="$SVCS(${R}$INACTIVE down${NC})"

# Docker containers (optimized with timeout)
DOCKER_LINE=""
if systemctl is-active --quiet docker 2>/dev/null && command_exists docker; then
    DOCKER_INFO=$(timeout 2 docker ps -a --format "{{.Status}}" 2>/dev/null)
    if [ -n "$DOCKER_INFO" ]; then
        RUNNING=$(echo "$DOCKER_INFO" | grep -c "^Up" || echo "0")
        TOTAL=$(echo "$DOCKER_INFO" | wc -l)
        [ "$TOTAL" -eq 0 ] && TOTAL=0
        DOCKER_LINE="Containers: ${G}$RUNNING${NC}/$TOTAL running"
    fi
fi

# Security services with parallel fail2ban check
SEC="F2B: $(svc_check fail2ban)  UFW: $(svc_check ufw)"
if systemctl is-active --quiet fail2ban 2>/dev/null && command_exists fail2ban-client; then
    # Use cache for fail2ban status (it can be slow)
    F2B_CACHE="$CACHE_DIR/fail2ban-status"
    if check_cache_file "$F2B_CACHE" 5; then  # 5 min cache for fail2ban
        BANS=$(timeout 2 fail2ban-client banned 2>/dev/null | grep -c "^[0-9]" || echo "0")
        safe_cache_write "$BANS" "$F2B_CACHE"
    else
        BANS=$(cat "$F2B_CACHE" 2>/dev/null || echo "0")
    fi
    [ "$BANS" -gt 0 ] && SEC="$SEC  (${Y}$BANS banned${NC})"
fi

# Updates & Maintenance with enhanced caching
MAINT_LINE=""
if command_exists apt-get; then
    # Cache apt updates check
    APT_CACHE="$CACHE_DIR/apt-updates"
    if check_cache_file "$APT_CACHE" "$CACHE_TTL_UPDATES"; then
        if [ -f /var/lib/apt/periodic/update-success-stamp ]; then
            timeout 3 apt list --upgradable 2>/dev/null | grep "upgradable" > "${APT_CACHE}.tmp" 2>/dev/null || true
            [ -f "${APT_CACHE}.tmp" ] && mv "${APT_CACHE}.tmp" "$APT_CACHE"
        fi
    fi
    
    if [ -s "$APT_CACHE" ]; then
        UPDATES=$(wc -l < "$APT_CACHE")
        SECURITY=$(grep -c "security" "$APT_CACHE" || echo "0")
        
        MAINT_LINE="Updates: ${Y}$UPDATES available"
        [ "$SECURITY" -gt 0 ] && MAINT_LINE="$MAINT_LINE ($SECURITY security)"
        MAINT_LINE="${MAINT_LINE}${NC}"
    fi
    
    # Autoremove check with caching
    AUTOREMOVE_CACHE="$CACHE_DIR/apt-autoremove"
    if check_cache_file "$AUTOREMOVE_CACHE" "$CACHE_TTL_AUTOREMOVE"; then
        AUTOREMOVE=$(timeout 2 apt-get --dry-run autoremove 2>/dev/null | grep -c "^Remv" || echo "0")
        safe_cache_write "$AUTOREMOVE" "$AUTOREMOVE_CACHE"
    else
        AUTOREMOVE=$(cat "$AUTOREMOVE_CACHE" 2>/dev/null || echo "0")
    fi
    
    if [ "$AUTOREMOVE" -gt 0 ]; then
        [ -n "$MAINT_LINE" ] && MAINT_LINE="$MAINT_LINE | "
        MAINT_LINE="${MAINT_LINE}${Y}$AUTOREMOVE to remove${NC}"
    fi
fi

# Future: Backup status (restic integration ready)
BACKUP=""
if command_exists restic && [ -f "/etc/restic/restic.conf" ]; then
    # Placeholder for restic implementation
    # BACKUP_CACHE="$CACHE_DIR/restic-status"
    # if check_cache_file "$BACKUP_CACHE" 60; then  # 1 hour cache
    #     LAST_BACKUP=$(timeout 5 restic snapshots --json --last 2>/dev/null | jq -r '.[0].time' 2>/dev/null | cut -d'T' -f1)
    #     safe_cache_write "$LAST_BACKUP" "$BACKUP_CACHE"
    # else
    #     LAST_BACKUP=$(cat "$BACKUP_CACHE" 2>/dev/null)
    # fi
    # [ -n "$LAST_BACKUP" ] && BACKUP="Backup: ${G}$LAST_BACKUP${NC}"
    true
fi

# Display output
echo
echo "${W}Welcome to ${C}$H${NC}"
echo "────────────────────────────────────────────────────────────"
echo "System: Up $UP | Load: $LOAD | Mem: $MEM | Disk: $DISK"
echo "Network: $IPS"
[ -n "$SVCS" ] && echo "Services: $SVCS"
echo "Security: $SEC"
[ -n "$DOCKER_LINE" ] && echo "$DOCKER_LINE"
[ -n "$MAINT_LINE" ] && echo "$MAINT_LINE"
[ -n "$BACKUP" ] && echo "$BACKUP"
echo